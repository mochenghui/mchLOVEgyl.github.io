---
layout:     post
title:      记录一次工作中遇到的CPU过高问题
subtitle:   CPU高、FullGC
date:       2020-12-15
author:     mochenghui
header-img: img/post-bg-android.jpg
catalog: true
tags:
    - Java
    - JVM
    - 工作记录
---
# 问题描述
某天早上突然收到服务告警，某个服务挂了，马上登录上机器看什么情况，发现重启后机器一切正常。
于是向运维申请了机器的各种参数指标，发现该服务每隔半个月就会重启一次，查看CPU占用情况，
在服务挂掉的时间点上机器的CPU负载非常高。由此开始了该问题的排查。
# 排查过程
- 查看CPU的占用时间规律，可以明显发现每隔半个月CPU的占用都是几乎直线上升，达到峰值后便会重启。
这个事情看起来就好像是OOM一样，内存一直占用没释放，达到峰值就挂掉，不同的是这是CPU,不是内存。
- 百度、谷歌双管齐下，发现也挺多人遇到这种CPU过高的问题，首先就是需要找到CPU占用高的线程。
- Arthas 工具的使用，傻瓜式安装使用，直接定位到CPU占用高的线程是FullGC线程，发现FullGC几乎每秒发生一次。
这样绝对是有问题。
- 排查为何导致了频繁FullGC,FullGC的发生是因为老年代放不下了，才需要进行FullGC,那为何会产生这么多的
老年代对象呢?
- jmap 打印堆内对象占用大小，发现了一个阿里云相关的对象，占用比较高。
- 排查该阿里云类相关的代码，发现问题了！原来是使用阿里云OSSClient时，每次进行图片上传都创建了一个client，
使用完后确没有关闭，导致这个对象一直在占用，无法释放，老年代堆积
- 修改OSSClient为单列使用，服务恢复正常。
# 尚未弄清楚的问题
- 如果OssClient一直无法被回收，即使发生了FullGC也应该不会回收，那应该发生OOM才对，为什么没有发生OOM?
- 虽然OSSClient的对象每次都创建，但是峰值时也就只占用了6m左右的内存，这个完全不会导致老年代被占满，为何会如此频繁触发FullGC?
- Jvm环境变量的最大堆内存配置了1000m,但是jmap查看对象总大小时已经完全超过了1000m,为何会没有OOM
# 待做
认真学习一遍Jvm相关的知识


